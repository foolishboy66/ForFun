package com.sf.svds.common.util;

import java.io.IOException;
import java.lang.reflect.Type;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.sql.Timestamp;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.Consts;
import org.apache.http.HttpEntity;
import org.apache.http.HttpRequest;
import org.apache.http.StatusLine;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpResponseException;
import org.apache.http.client.ResponseHandler;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.config.SocketConfig;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.internal.bind.TypeAdapters;
import com.google.gson.reflect.TypeToken;
import com.sf.framework.domain.Result;
import com.sf.svds.common.adapter.DateTypeAdapter;
import com.sf.svds.common.exception.BusinessRuntimeException;

/**
 * 发送http请求工具类
 *
 * @author 80002834 on 2017/10/26 17:32
 */
public class HttpUtils {

    private static final Logger logger = LoggerFactory.getLogger(HttpUtils.class);

    private static final CloseableHttpClient HTTP_CLIENT;

    /**
     * 最大连接数
     */
    private static final int MAX_TOTAL = 1000;

    /**
     * 同一host最大连接数
     */
    private static final int MAX_PER_ROUTE = 200;

    /**
     * 建立连接超时时间
     */
    private static final int CONNECT_TIMEOUT_MILLIS = 60 * 1000;

    /**
     * Socket超时时间
     */
    private static final int SOCKET_TIMEOUT_MILLIS = 30 * 1000;

    /**
     * 从连接池中请求连接超时时间
     */
    private static final int CONNECTION_REQUEST_TIMEOUT_MILLIS = 30 * 1000;

    /**
     * 连接闲置最大时间
     */
    private static final long MAX_IDLE_SECONDS = 180;

    private static final int MIN_HTTP_STATUS_ERROR_CODE = 300;

    private static ResponseHandler<String> responseHandler = response -> {
        StatusLine statusLine = response.getStatusLine();
        HttpEntity entity = response.getEntity();
        if (statusLine.getStatusCode() >= MIN_HTTP_STATUS_ERROR_CODE) {
            throw new HttpResponseException(statusLine.getStatusCode(), statusLine.getReasonPhrase());
        }
        if (entity == null) {
            throw new ClientProtocolException("Response contains no content");
        }

        return EntityUtils.toString(response.getEntity(), Consts.UTF_8);
    };

    private static final Gson GSON = new GsonBuilder().registerTypeAdapterFactory(newDateTypeAdapterFactory(Date.class))
            .registerTypeAdapterFactory(newDateTypeAdapterFactory(Timestamp.class))
            .registerTypeAdapterFactory(newDateTypeAdapterFactory(java.sql.Date.class)).create();

    static {

        SSLContext ctx;
        try {
            ctx = ignoreSSLContext();
        } catch (Exception e) {
            throw new BusinessRuntimeException(e);
        }

        SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory(ctx,
                ignoreHostnameVerifier());
        Registry<ConnectionSocketFactory> socketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create()
                .register("http", PlainConnectionSocketFactory.getSocketFactory())
                .register("https", sslConnectionSocketFactory).build();
        SocketConfig socketConfig = SocketConfig.custom().setTcpNoDelay(true).build();

        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager(
                socketFactoryRegistry);
        connectionManager.setMaxTotal(MAX_TOTAL);
        connectionManager.setDefaultMaxPerRoute(MAX_PER_ROUTE);
        connectionManager.setDefaultSocketConfig(socketConfig);

        RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(CONNECT_TIMEOUT_MILLIS)
                .setSocketTimeout(SOCKET_TIMEOUT_MILLIS).setConnectionRequestTimeout(CONNECTION_REQUEST_TIMEOUT_MILLIS)
                .build();

        HTTP_CLIENT = HttpClients.custom().setConnectionManager(connectionManager)
                .setDefaultRequestConfig(requestConfig).evictIdleConnections(MAX_IDLE_SECONDS, TimeUnit.SECONDS)
                .evictExpiredConnections().build();

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                HTTP_CLIENT.close();
            } catch (IOException e) {
                logger.error(e.getMessage(), e);
            }
        }));
    }

    private HttpUtils() {

    }

    /**
     * post请求，返回为Result<T>类型
     *
     * @param path
     *            请求地址
     * @param request
     *            请求参数
     * @param responseType
     *            返回参数类型（T的class）
     * 
     * @return Result<T>
     */
    public static <T> Result<T> post(String path, Object request, Class<T> responseType) {

        return post(path, null, request, responseType, true, true);
    }

    /**
     * 带header的post请求
     *
     * @param path
     *            请求地址
     * @param header
     *            请求头
     * @param request
     *            请求参数
     * @param responseType
     *            返回参数类型（T的class）
     * 
     * @return Result<T>
     */
    public static <T> Result<T> post(String path, Map<String, String> header, Object request, Class<T> responseType) {

        return post(path, header, request, responseType, true, true);
    }

    public static <T> Result<T> post(String path, Map<String, String> header, Object request, Class<T> responseType,
            boolean logRequest, boolean logResponse) {

        return postUseGson(path, header, request, $Result(responseType), logRequest, logResponse);
    }

    public static <T> Result<T> post(String path, Map<String, String> header, Object request, String describe,
            Class<T> responseType, boolean logRequest, boolean logResponse) {

        return postUseGson(path, header, request, describe, $Result(responseType), logRequest, logResponse);
    }

    /**
     * post请求，返回为Result<List<T>>类型
     *
     * @param path
     *            请求地址
     * @param request
     *            请求参数
     * @param responseType
     *            返回参数类型（T的class）
     * @param <T>
     *            response T
     * @return Result of List<T>
     */
    public static <T> Result<List<T>> postList(String path, Object request, Class<T> responseType) {

        return postList(path, null, request, responseType, true, true);
    }

    public static <T> Result<List<T>> postList(String path, Map<String, String> header, Object request,
            Class<T> responseType) {

        return postList(path, header, request, responseType, true, true);
    }

    public static <T> Result<List<T>> postList(String path, Map<String, String> header, Object request,
            Class<T> responseType, boolean logRequest, boolean logResponse) {

        return postUseGson(path, header, request, $Result($List(responseType)), logRequest, logResponse);
    }

    /**
     * post请求，返回为T
     *
     * @param path
     *            请求地址
     * @param request
     *            请求参数
     * @param responseType
     *            返回参数类型
     * @param <T>
     *            response T
     * @return T
     */
    public static <T> T postRaw(String path, Object request, Type responseType) {

        return postRaw(path, null, request, responseType, true, true);
    }

    public static <T> T postRaw(String path, Map<String, String> header, Object request, Type responseType) {

        return postRaw(path, header, request, responseType, true, true);
    }

    public static <T> T postRaw(String path, Map<String, String> header, Object request, Type responseType,
            boolean logRequest, boolean logResponse) {

        return postUseGson(path, header, request, responseType, logRequest, logResponse);
    }

    /**
     * post请求，返回原始String
     *
     * @param path
     *            请求地址
     * @param request
     *            请求参数
     * @return 原始response
     */
    public static String postString(String path, Object request) {

        return postString(path, null, request, true, true);
    }

    /**
     * 发送get请求
     * 
     * @param path
     * @param result
     * @param describe
     * @return
     */
    public static <T> Result<T> get(String path, Result<T> result, String describe) {

        return get(path, describe, new TypeToken<Result<T>>() {

        }.getType());
    }

    /**
     * 发送put请求
     * 
     * @param path
     * @param request
     * @param describe
     * @param type
     * @return
     */
    public static <T> Result<T> put(String path, Object request, String describe, Type type) {

        logger.info(" {}\npath: {}, body: {}", describe, path, request);
        String response = put0(path, null, GSON.toJson(request));
        logger.info(" {}\nresponse: {}", describe, response);
        return GSON.fromJson(response, type);
    }

    /**
     * 发送delete请求
     * 
     * @param path
     * @param header
     * @param describe
     * @param type
     * @return
     */
    public static <T> Result<T> delete(String path, Map<String, String> header, String describe, Type type) {

        logger.info(" {}\npath: {}", describe, path);
        String response = delete0(path, header);
        logger.info(" {}\nresponse: {}", describe, response);
        return GSON.fromJson(response, type);
    }

    public static String postString(String path, Map<String, String> header, Object request) {

        return postString(path, header, request, true, true);
    }

    public static String postString(String path, Map<String, String> header, Object request, boolean logRequest,
            boolean logResponse) {

        return post0(path, header, GSON.toJson(request), logRequest, logResponse);
    }

    private static Type $Result(Type type) {

        return TypeToken.getParameterized(Result.class, type).getType();
    }

    private static Type $List(Type type) {

        return TypeToken.getParameterized(List.class, type).getType();
    }

    private static <T> T postUseGson(String path, Map<String, String> header, Object request, Type responseType,
            boolean logRequest, boolean logResponse) {

        return GSON.fromJson(post0(path, header, GSON.toJson(request), logRequest, logResponse), responseType);
    }

    private static <T> T postUseGson(String path, Map<String, String> header, Object request, String describe,
            Type responseType, boolean logRequest, boolean logResponse) {

        return GSON.fromJson(post0(path, header, GSON.toJson(request), describe, logRequest, logResponse),
                responseType);
    }

    private static String post0(String path, Map<String, String> header, String request, boolean logRequest,
            boolean logResponse) {

        String messageId = "";
        if (logRequest) {
            messageId = UUIDUtils.getUUID();
            logger.info(" -> messageId: {}\npath: {}, header: {}, body: {}", messageId, path, header, request);
        }
        String response = post0(path, header, request);
        if (logResponse) {
            logger.info(" <- messageId: {}\nresponse: {}", messageId, response);
        }

        return response;
    }

    private static String post0(String path, Map<String, String> header, String request, String describe,
            boolean logRequest, boolean logResponse) {

        String messageId = "";
        if (logRequest) {
            messageId = UUIDUtils.getUUID();
            logger.info(" -> messageId: {}, {}\npath: {}, header: {}, body: {}", messageId, describe, path, header,
                    request);
        }
        String response = post0(path, header, request);
        if (logResponse) {
            logger.info("-> messageId: {}, {}\nresponse: {}", messageId, describe, response);
        }

        return response;
    }

    private static String post0(String path, Map<String, String> header, String request) {

        HttpPost post = new HttpPost(path);
        buildWithHeader(post, header);
        buildWithEntity(post, request, ContentType.APPLICATION_JSON.getMimeType());
        try {
            return execute(post);
        } catch (Exception e) {
            throw new BusinessRuntimeException(HttpErrorConstants.HTTP_POST_ERROR_MESSAGE, e.getMessage(), e);
        }
    }

    private static String get0(String path, Map<String, String> header) {

        HttpGet get = new HttpGet(path);
        buildWithHeader(get, header);
        try {
            return execute(get);
        } catch (Exception e) {
            throw new BusinessRuntimeException(HttpErrorConstants.HTTP_GET_ERROR_MESSAGE, e.getMessage(), e);
        }
    }

    private static String put0(String path, Map<String, String> header, String request) {

        HttpPut put = new HttpPut(path);
        buildWithHeader(put, header);
        buildWithEntity(put, request, ContentType.APPLICATION_JSON.getMimeType());
        try {
            return execute(put);
        } catch (Exception e) {
            throw new BusinessRuntimeException(HttpErrorConstants.HTTP_PUT_ERROR_MESSAGE, e.getMessage(), e);
        }
    }

    private static String delete0(String path, Map<String, String> header) {

        HttpDelete delete = new HttpDelete(path);
        buildWithHeader(delete, header);
        try {
            return execute(delete);
        } catch (Exception e) {
            throw new BusinessRuntimeException(HttpErrorConstants.HTTP_DELETE_ERROR_MESSAGE, e.getMessage(), e);
        }
    }

    private static void buildWithHeader(HttpRequest request, Map<String, String> header) {

        if (header != null) {
            header.forEach(request::addHeader);
        }
    }

    private static void buildWithEntity(HttpEntityEnclosingRequestBase request, String entity, String mimeType) {

        request.setEntity(new StringEntity(entity, ContentType.create(mimeType, Consts.UTF_8)));
    }

    private static String execute(HttpUriRequest request) throws IOException {

        return HTTP_CLIENT.execute(request, responseHandler);
    }

    /**
     * @return Result
     */
    public static <T> T get(String path, String describe, Type type) {

        logger.info(" {}\npath: {}", describe, path);
        String response = get0(path, null);
        logger.info(" {}\nresponse: {}", describe, response);
        return GSON.fromJson(response, type);
    }

    private static SSLContext ignoreSSLContext() throws NoSuchAlgorithmException, KeyManagementException {

        SSLContext sc = SSLContext.getInstance("TLSv1.2");
        sc.init(null, new TrustManager[] { ignoreX509TrustManager() }, new SecureRandom());
        return sc;
    }

    private static TrustManager ignoreX509TrustManager() {

        return new X509TrustManager() {

            @Override
            public void checkClientTrusted(X509Certificate[] x509Certificates, String s) {

            }

            @Override
            public void checkServerTrusted(X509Certificate[] x509Certificates, String s) {

            }

            @Override
            public X509Certificate[] getAcceptedIssuers() {

                return new X509Certificate[0];
            }
        };
    }

    private static HostnameVerifier ignoreHostnameVerifier() {

        return (hostname, session) -> true;
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    private static TypeAdapterFactory newDateTypeAdapterFactory(final Class<? extends Date> type) {

        TypeAdapter typeAdapter = new DateTypeAdapter(type);
        return TypeAdapters.newFactory(type, typeAdapter.nullSafe());
    }
    
    /**
     * http异常描述
     */
    private static interface HttpErrorConstants {

        public static final String HTTP_GET_ERROR_MESSAGE = "Http GET method invoke error!";
        public static final String HTTP_POST_ERROR_MESSAGE = "Http POST method invoke error!";
        public static final String HTTP_PUT_ERROR_MESSAGE = "Http PUT method invoke error!";
        public static final String HTTP_DELETE_ERROR_MESSAGE = "Http DELETE method invoke error!";

    }

    public static Map<String, String> constructHeaderMap(String zoneCode) {

        Map<String, String> hashMap = new HashMap<String, String>();

        hashMap.put("citycode", StringUtils.extractCityCode(zoneCode));
        hashMap.put("zonecode", zoneCode);
        hashMap.put("empcode", zoneCode);
        return hashMap;
    }
}
